<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉树层次遍历可视化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        
        .tree-container {
            flex: 1;
            min-width: 500px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .tree-canvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .explanation {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }
        
        .explanation h2 {
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8rem;
            color: #ffcc00;
        }
        
        .step-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            flex-grow: 1;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .step-info h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .visited-nodes {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .visited-nodes h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .visited-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .visited-node {
            background: #4caf50;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }
        
        .queue-status {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .queue-status h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }
        
        .queue-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .queue-node {
            background: #ff9800;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 25px;
            font-size: 1.1rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        #prevBtn {
            background: #ff5722;
            color: white;
        }
        
        #nextBtn {
            background: #4caf50;
            color: white;
        }
        
        #resetBtn {
            background: #2196f3;
            color: white;
        }
        
        .config-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        
        .config-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }
        
        .config-group label {
            font-weight: bold;
            color: #ffcc00;
        }
        
        select {
            padding: 10px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .tree-container, .explanation {
                min-width: 100%;
            }
            
            .config-panel {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>二叉树层次遍历可视化</h1>
            <p class="subtitle">广度优先遍历 - 按层级从上到下、从左到右访问节点</p>
        </header>
        
        <div class="config-panel">
            <div class="config-group">
                <label for="traversalType">遍历算法:</label>
                <select id="traversalType">
                    <option value="levelorder">层次遍历 (广度优先)</option>
                    <option value="preorder">前序遍历 (根-左-右)</option>
                    <option value="inorder">中序遍历 (左-根-右)</option>
                    <option value="postorder">后序遍历 (左-右-根)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label for="treePreset">树结构:</label>
                <select id="treePreset">
                    <option value="default">默认树</option>
                    <option value="balanced">平衡树</option>
                    <option value="leftSkewed">左斜树</option>
                    <option value="rightSkewed">右斜树</option>
                    <option value="complex">复杂树</option>
                </select>
            </div>
        </div>
        
        <div class="content">
            <div class="tree-container">
                <h2>二叉树结构</h2>
                <canvas id="treeCanvas" width="600" height="400" class="tree-canvas"></canvas>
            </div>
            
            <div class="explanation">
                <h2>遍历过程说明</h2>
                <div class="step-info">
                    <h3>步骤 <span id="stepNum">0</span>: <span id="stepTitle">准备开始</span></h3>
                    <p id="stepDescription">选择遍历算法和树结构，然后点击"下一步"开始遍历演示。</p>
                </div>
                
                <div class="visited-nodes">
                    <h3>已访问节点</h3>
                    <div class="visited-list" id="visitedNodes">
                        <!-- 已访问节点将在这里显示 -->
                    </div>
                </div>
                
                <div class="queue-status" id="queueStatus">
                    <h3>当前队列</h3>
                    <div class="queue-list" id="queueNodes">
                        <!-- 队列中的节点将在这里显示 -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="prevBtn">上一步</button>
            <button id="nextBtn">下一步</button>
            <button id="resetBtn">重置</button>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2196F3;"></div>
                <span>未访问节点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FF9800;"></div>
                <span>当前节点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4CAF50;"></div>
                <span>已访问节点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #9C27B0;"></div>
                <span>队列中的节点</span>
            </div>
        </div>
    </div>

    <script>
        // 二叉树节点类
        class TreeNode {
            constructor(value, x, y) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.left = null;
                this.right = null;
                this.radius = 25;
                this.visited = false;
                this.active = false;
                this.inQueue = false;
            }
        }

        // 二叉树类
        class BinaryTree {
            constructor() {
                this.root = null;
                this.steps = [];
                this.currentStep = 0;
                this.visitedNodes = [];
                this.traversalType = 'levelorder';
                this.treeType = 'default';
                this.initTree('default');
            }

            // 初始化树结构
            initTree(type) {
                this.treeType = type;
                
                // 根据类型创建不同的树结构
                switch(type) {
                    case 'default':
                        this.createDefaultTree();
                        break;
                    case 'balanced':
                        this.createBalancedTree();
                        break;
                    case 'leftSkewed':
                        this.createLeftSkewedTree();
                        break;
                    case 'rightSkewed':
                        this.createRightSkewedTree();
                        break;
                    case 'complex':
                        this.createComplexTree();
                        break;
                }
                
                this.generateSteps();
            }

            // 创建默认树
            createDefaultTree() {
                const nodeA = new TreeNode('A', 300, 50);
                const nodeB = new TreeNode('B', 200, 150);
                const nodeC = new TreeNode('C', 400, 150);
                const nodeD = new TreeNode('D', 150, 250);
                const nodeE = new TreeNode('E', 250, 250);
                const nodeF = new TreeNode('F', 450, 250);
                const nodeG = new TreeNode('G', 220, 350);

                nodeA.left = nodeB;
                nodeA.right = nodeC;
                nodeB.left = nodeD;
                nodeB.right = nodeE;
                nodeC.right = nodeF;
                nodeE.left = nodeG;

                this.root = nodeA;
            }

            // 创建平衡树
            createBalancedTree() {
                const nodeA = new TreeNode('A', 300, 50);
                const nodeB = new TreeNode('B', 200, 150);
                const nodeC = new TreeNode('C', 400, 150);
                const nodeD = new TreeNode('D', 150, 250);
                const nodeE = new TreeNode('E', 250, 250);
                const nodeF = new TreeNode('F', 350, 250);
                const nodeG = new TreeNode('G', 450, 250);

                nodeA.left = nodeB;
                nodeA.right = nodeC;
                nodeB.left = nodeD;
                nodeB.right = nodeE;
                nodeC.left = nodeF;
                nodeC.right = nodeG;

                this.root = nodeA;
            }

            // 创建左斜树
            createLeftSkewedTree() {
                const nodeA = new TreeNode('A', 300, 50);
                const nodeB = new TreeNode('B', 250, 150);
                const nodeC = new TreeNode('C', 200, 250);
                const nodeD = new TreeNode('D', 150, 350);

                nodeA.left = nodeB;
                nodeB.left = nodeC;
                nodeC.left = nodeD;

                this.root = nodeA;
            }

            // 创建右斜树
            createRightSkewedTree() {
                const nodeA = new TreeNode('A', 300, 50);
                const nodeB = new TreeNode('B', 350, 150);
                const nodeC = new TreeNode('C', 400, 250);
                const nodeD = new TreeNode('D', 450, 350);

                nodeA.right = nodeB;
                nodeB.right = nodeC;
                nodeC.right = nodeD;

                this.root = nodeA;
            }

            // 创建复杂树
            createComplexTree() {
                const nodeA = new TreeNode('A', 300, 50);
                const nodeB = new TreeNode('B', 200, 150);
                const nodeC = new TreeNode('C', 400, 150);
                const nodeD = new TreeNode('D', 150, 250);
                const nodeE = new TreeNode('E', 250, 250);
                const nodeF = new TreeNode('F', 450, 250);
                const nodeG = new TreeNode('G', 180, 350);
                const nodeH = new TreeNode('H', 220, 350);
                const nodeI = new TreeNode('I', 480, 350);

                nodeA.left = nodeB;
                nodeA.right = nodeC;
                nodeB.left = nodeD;
                nodeB.right = nodeE;
                nodeC.right = nodeF;
                nodeD.left = nodeG;
                nodeD.right = nodeH;
                nodeF.right = nodeI;

                this.root = nodeA;
            }

            // 设置遍历类型
            setTraversalType(type) {
                this.traversalType = type;
                this.generateSteps();
            }

            // 生成遍历步骤
            generateSteps() {
                this.steps = [];
                
                switch(this.traversalType) {
                    case 'preorder':
                        this.preorderTraversal(this.root, []);
                        break;
                    case 'inorder':
                        this.inorderTraversal(this.root, []);
                        break;
                    case 'postorder':
                        this.postorderTraversal(this.root, []);
                        break;
                    case 'levelorder':
                        this.levelorderTraversal();
                        break;
                }
            }

            // 层次遍历
            levelorderTraversal() {
                if (!this.root) return;
                
                // 初始化队列
                const queue = [this.root];
                const queueValues = [this.root.value];
                
                // 步骤1: 初始化队列
                this.steps.push({
                    title: "初始化队列",
                    description: `将根节点 ${this.root.value} 加入队列。`,
                    node: this.root,
                    queue: [...queueValues],
                    action: 'initQueue'
                });
                
                while (queue.length > 0) {
                    // 步骤2: 从队列中取出节点
                    const currentNode = queue.shift();
                    const currentValue = queueValues.shift();
                    
                    this.steps.push({
                        title: `访问节点 ${currentNode.value}`,
                        description: `从队列中取出节点 ${currentNode.value} 并访问它。`,
                        node: currentNode,
                        queue: [...queueValues],
                        action: 'visit',
                        visited: true
                    });
                    
                    // 将左子节点加入队列
                    if (currentNode.left) {
                        queue.push(currentNode.left);
                        queueValues.push(currentNode.left.value);
                        
                        this.steps.push({
                            title: `将 ${currentNode.value} 的左子节点加入队列`,
                            description: `将节点 ${currentNode.left.value} 加入队列。`,
                            node: currentNode,
                            queue: [...queueValues],
                            action: 'enqueueLeft'
                        });
                    }
                    
                    // 将右子节点加入队列
                    if (currentNode.right) {
                        queue.push(currentNode.right);
                        queueValues.push(currentNode.right.value);
                        
                        this.steps.push({
                            title: `将 ${currentNode.value} 的右子节点加入队列`,
                            description: `将节点 ${currentNode.right.value} 加入队列。`,
                            node: currentNode,
                            queue: [...queueValues],
                            action: 'enqueueRight'
                        });
                    }
                }
                
                // 步骤3: 遍历完成
                this.steps.push({
                    title: "遍历完成",
                    description: "层次遍历已完成所有节点的访问。",
                    node: null,
                    queue: [],
                    action: 'complete'
                });
            }

            // 前序遍历递归函数
            preorderTraversal(node, path) {
                if (!node) return;

                // 步骤1: 访问节点
                const step1 = {
                    title: `访问节点 ${node.value}`,
                    description: `按照前序遍历规则(根-左-右)，我们首先访问节点 ${node.value}。`,
                    node: node,
                    path: [...path, node.value],
                    action: 'visit',
                    visited: true
                };
                this.steps.push(step1);

                // 步骤2: 遍历左子树
                if (node.left) {
                    const step2 = {
                        title: `前往 ${node.value} 的左子树`,
                        description: `节点 ${node.value} 有左子树，我们前往节点 ${node.left.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'goLeft'
                    };
                    this.steps.push(step2);
                    
                    this.preorderTraversal(node.left, [...path, node.value]);
                    
                    // 步骤3: 从左子树返回
                    const step3 = {
                        title: `从 ${node.left.value} 返回 ${node.value}`,
                        description: `节点 ${node.value} 的左子树遍历完成。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'returnFromLeft'
                    };
                    this.steps.push(step3);
                } else {
                    // 没有左子树
                    const step2 = {
                        title: `${node.value} 没有左子树`,
                        description: `节点 ${node.value} 没有左子树，继续处理右子树。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'noLeft'
                    };
                    this.steps.push(step2);
                }

                // 步骤4: 遍历右子树
                if (node.right) {
                    const step4 = {
                        title: `前往 ${node.value} 的右子树`,
                        description: `节点 ${node.value} 有右子树，我们前往节点 ${node.right.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'goRight'
                    };
                    this.steps.push(step4);
                    
                    this.preorderTraversal(node.right, [...path, node.value]);
                    
                    // 步骤5: 从右子树返回
                    const step5 = {
                        title: `从 ${node.right.value} 返回 ${node.value}`,
                        description: `节点 ${node.value} 的右子树遍历完成。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'returnFromRight'
                    };
                    this.steps.push(step5);
                } else {
                    // 没有右子树
                    const step4 = {
                        title: `${node.value} 没有右子树`,
                        description: `节点 ${node.value} 没有右子树，以 ${node.value} 为根的子树遍历完成。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'noRight'
                    };
                    this.steps.push(step4);
                }
            }

            // 中序遍历递归函数
            inorderTraversal(node, path) {
                if (!node) return;

                // 步骤1: 到达节点
                const step1 = {
                    title: `到达节点 ${node.value}`,
                    description: `我们到达节点 ${node.value}，按照中序遍历规则(左-根-右)，我们需要先访问它的左子树。`,
                    node: node,
                    path: [...path, node.value],
                    action: 'arrive'
                };
                this.steps.push(step1);

                // 步骤2: 遍历左子树
                if (node.left) {
                    const step2 = {
                        title: `前往 ${node.value} 的左子树`,
                        description: `节点 ${node.value} 有左子树，我们前往节点 ${node.left.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'goLeft'
                    };
                    this.steps.push(step2);
                    
                    this.inorderTraversal(node.left, [...path, node.value]);
                    
                    // 步骤3: 从左子树返回
                    const step3 = {
                        title: `从 ${node.left.value} 返回 ${node.value}`,
                        description: `节点 ${node.value} 的左子树遍历完成，现在我们可以访问节点 ${node.value} 了。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'returnFromLeft'
                    };
                    this.steps.push(step3);
                } else {
                    // 没有左子树
                    const step2 = {
                        title: `${node.value} 没有左子树`,
                        description: `节点 ${node.value} 没有左子树，按照中序遍历规则，现在我们可以访问节点 ${node.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'noLeft'
                    };
                    this.steps.push(step2);
                }

                // 步骤4: 访问节点
                const step4 = {
                    title: `访问节点 ${node.value}`,
                    description: `我们访问节点 ${node.value}，将其添加到已访问节点列表中。`,
                    node: node,
                    path: [...path, node.value],
                    action: 'visit',
                    visited: true
                };
                this.steps.push(step4);

                // 步骤5: 遍历右子树
                if (node.right) {
                    const step5 = {
                        title: `前往 ${node.value} 的右子树`,
                        description: `节点 ${node.value} 有右子树，我们前往节点 ${node.right.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'goRight'
                    };
                    this.steps.push(step5);
                    
                    this.inorderTraversal(node.right, [...path, node.value]);
                    
                    // 步骤6: 从右子树返回
                    const step6 = {
                        title: `从 ${node.right.value} 返回 ${node.value}`,
                        description: `节点 ${node.value} 的右子树遍历完成。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'returnFromRight'
                    };
                    this.steps.push(step6);
                } else {
                    // 没有右子树
                    const step5 = {
                        title: `${node.value} 没有右子树`,
                        description: `节点 ${node.value} 没有右子树，以 ${node.value} 为根的子树遍历完成。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'noRight'
                    };
                    this.steps.push(step5);
                }
            }

            // 后序遍历递归函数
            postorderTraversal(node, path) {
                if (!node) return;

                // 步骤1: 到达节点
                const step1 = {
                    title: `到达节点 ${node.value}`,
                    description: `我们到达节点 ${node.value}，按照后序遍历规则(左-右-根)，我们需要先访问它的左子树。`,
                    node: node,
                    path: [...path, node.value],
                    action: 'arrive'
                };
                this.steps.push(step1);

                // 步骤2: 遍历左子树
                if (node.left) {
                    const step2 = {
                        title: `前往 ${node.value} 的左子树`,
                        description: `节点 ${node.value} 有左子树，我们前往节点 ${node.left.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'goLeft'
                    };
                    this.steps.push(step2);
                    
                    this.postorderTraversal(node.left, [...path, node.value]);
                    
                    // 步骤3: 从左子树返回
                    const step3 = {
                        title: `从 ${node.left.value} 返回 ${node.value}`,
                        description: `节点 ${node.value} 的左子树遍历完成。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'returnFromLeft'
                    };
                    this.steps.push(step3);
                } else {
                    // 没有左子树
                    const step2 = {
                        title: `${node.value} 没有左子树`,
                        description: `节点 ${node.value} 没有左子树，继续处理右子树。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'noLeft'
                    };
                    this.steps.push(step2);
                }

                // 步骤4: 遍历右子树
                if (node.right) {
                    const step4 = {
                        title: `前往 ${node.value} 的右子树`,
                        description: `节点 ${node.value} 有右子树，我们前往节点 ${node.right.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'goRight'
                    };
                    this.steps.push(step4);
                    
                    this.postorderTraversal(node.right, [...path, node.value]);
                    
                    // 步骤5: 从右子树返回
                    const step5 = {
                        title: `从 ${node.right.value} 返回 ${node.value}`,
                        description: `节点 ${node.value} 的右子树遍历完成，现在我们可以访问节点 ${node.value} 了。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'returnFromRight'
                    };
                    this.steps.push(step5);
                } else {
                    // 没有右子树
                    const step4 = {
                        title: `${node.value} 没有右子树`,
                        description: `节点 ${node.value} 没有右子树，按照后序遍历规则，现在我们可以访问节点 ${node.value}。`,
                        node: node,
                        path: [...path, node.value],
                        action: 'noRight'
                    };
                    this.steps.push(step4);
                }

                // 步骤6: 访问节点
                const step6 = {
                    title: `访问节点 ${node.value}`,
                    description: `我们访问节点 ${node.value}，将其添加到已访问节点列表中。`,
                    node: node,
                    path: [...path, node.value],
                    action: 'visit',
                    visited: true
                };
                this.steps.push(step6);
            }

            // 获取当前步骤
            getCurrentStep() {
                if (this.currentStep < this.steps.length) {
                    return this.steps[this.currentStep];
                }
                return {
                    title: "遍历完成",
                    description: `${this.getTraversalName()}遍历已完成所有节点的访问。`,
                    node: null,
                    queue: [],
                    action: 'complete'
                };
            }

            // 获取遍历名称
            getTraversalName() {
                switch(this.traversalType) {
                    case 'preorder': return '前序';
                    case 'inorder': return '中序';
                    case 'postorder': return '后序';
                    case 'levelorder': return '层次';
                    default: return '';
                }
            }

            // 下一步
            nextStep() {
                if (this.currentStep < this.steps.length) {
                    const step = this.steps[this.currentStep];
                    if (step.visited) {
                        this.visitedNodes.push(step.node.value);
                    }
                    this.currentStep++;
                }
            }

            // 上一步
            prevStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    const step = this.steps[this.currentStep];
                    if (step.visited) {
                        this.visitedNodes.pop();
                    }
                }
            }

            // 重置
            reset() {
                this.currentStep = 0;
                this.visitedNodes = [];
            }

            // 获取当前队列
            getCurrentQueue() {
                if (this.currentStep < this.steps.length) {
                    return this.steps[this.currentStep].queue || [];
                }
                return [];
            }
        }

        // 绘制树
        function drawTree(ctx, tree) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // 绘制连线
            drawConnections(ctx, tree.root);
            
            // 绘制节点
            drawNodes(ctx, tree.root, tree);
        }

        // 绘制节点连线
        function drawConnections(ctx, node) {
            if (!node) return;
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            
            if (node.left) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y + node.radius);
                ctx.lineTo(node.left.x, node.left.y - node.left.radius);
                ctx.stroke();
                drawConnections(ctx, node.left);
            }
            
            if (node.right) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y + node.radius);
                ctx.lineTo(node.right.x, node.right.y - node.right.radius);
                ctx.stroke();
                drawConnections(ctx, node.right);
            }
        }

        // 绘制节点
        function drawNodes(ctx, node, tree) {
            if (!node) return;
            
            const step = tree.getCurrentStep();
            const queue = tree.getCurrentQueue();
            
            // 设置节点颜色
            let color = '#2196F3'; // 默认蓝色
            
            if (node.visited) {
                color = '#4CAF50'; // 已访问绿色
            }
            
            if (step.node === node) {
                color = '#FF9800'; // 当前节点橙色
            }
            
            // 检查节点是否在队列中
            if (queue.includes(node.value)) {
                color = '#9C27B0'; // 队列中的节点紫色
            }
            
            // 绘制节点
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制节点边框
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制节点文本
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.value, node.x, node.y);
            
            // 递归绘制子节点
            drawNodes(ctx, node.left, tree);
            drawNodes(ctx, node.right, tree);
        }

        // 更新节点访问状态
        function updateNodeVisited(tree) {
            // 重置所有节点的访问状态
            function resetNodes(node) {
                if (!node) return;
                node.visited = false;
                resetNodes(node.left);
                resetNodes(node.right);
            }
            
            resetNodes(tree.root);
            
            // 设置已访问节点
            for (let value of tree.visitedNodes) {
                function setVisited(node) {
                    if (!node) return false;
                    if (node.value === value) {
                        node.visited = true;
                        return true;
                    }
                    return setVisited(node.left) || setVisited(node.right);
                }
                
                setVisited(tree.root);
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');
            const stepNumElement = document.getElementById('stepNum');
            const stepTitleElement = document.getElementById('stepTitle');
            const stepDescriptionElement = document.getElementById('stepDescription');
            const visitedNodesElement = document.getElementById('visitedNodes');
            const queueNodesElement = document.getElementById('queueNodes');
            const queueStatusElement = document.getElementById('queueStatus');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const resetBtn = document.getElementById('resetBtn');
            const traversalTypeSelect = document.getElementById('traversalType');
            const treePresetSelect = document.getElementById('treePreset');
            
            const tree = new BinaryTree();
            
            // 更新显示
            function updateDisplay() {
                const step = tree.getCurrentStep();
                
                stepNumElement.textContent = tree.currentStep;
                stepTitleElement.textContent = step.title;
                stepDescriptionElement.textContent = step.description;
                
                // 更新已访问节点显示
                visitedNodesElement.innerHTML = '';
                tree.visitedNodes.forEach(nodeValue => {
                    const nodeElement = document.createElement('div');
                    nodeElement.className = 'visited-node';
                    nodeElement.textContent = nodeValue;
                    visitedNodesElement.appendChild(nodeElement);
                });
                
                // 更新队列显示
                queueNodesElement.innerHTML = '';
                if (tree.traversalType === 'levelorder' && step.queue) {
                    step.queue.forEach(nodeValue => {
                        const nodeElement = document.createElement('div');
                        nodeElement.className = 'queue-node';
                        nodeElement.textContent = nodeValue;
                        queueNodesElement.appendChild(nodeElement);
                    });
                    
                    // 显示队列状态
                    queueStatusElement.style.display = 'block';
                } else {
                    // 隐藏队列状态
                    queueStatusElement.style.display = 'none';
                }
                
                // 更新节点访问状态
                updateNodeVisited(tree);
                
                // 重绘树
                drawTree(ctx, tree);
                
                // 更新按钮状态
                prevBtn.disabled = tree.currentStep === 0;
                nextBtn.disabled = tree.currentStep >= tree.steps.length;
            }
            
            // 事件监听
            nextBtn.addEventListener('click', function() {
                tree.nextStep();
                updateDisplay();
            });
            
            prevBtn.addEventListener('click', function() {
                tree.prevStep();
                updateDisplay();
            });
            
            resetBtn.addEventListener('click', function() {
                tree.reset();
                updateDisplay();
            });
            
            traversalTypeSelect.addEventListener('change', function() {
                tree.setTraversalType(this.value);
                tree.reset();
                updateDisplay();
            });
            
            treePresetSelect.addEventListener('change', function() {
                tree.initTree(this.value);
                tree.reset();
                updateDisplay();
            });
            
            // 初始显示
            updateDisplay();
        });
    </script>
</body>
</html>